@page "/"
@using Markdig
@using System.Text.Json
@using Microsoft.AspNetCore.Components.Web
@using System.Net
@using System.Text.RegularExpressions
@using OpenAI
@using OpenAI.Chat
@using System.ClientModel
@using frontend.Tools
@inject HttpClient Http
@inject IConfiguration Configuration
@rendermode InteractiveServer

@* 
PSEUDOCODE / PLAN (detailed):
- Goal: Render chat message content in a "HTML/Word-like" format:
  - Preserve actual line breaks and paragraphs.
  - Handle cases where the backend returns literal escape sequences like "\n" (backslash + n).
  - Render simple HTML if content appears to be HTML.
  - Otherwise, escape HTML and convert real newlines to <br/> so text looks like Word paragraphs.
- Steps inside RenderMessage:
  1. If `content` is null/empty => return empty MarkupString.
  2. Unescape common escaped sequences using `Regex.Unescape(content)` to convert literal "\n" into real newlines.
  3. Remove the first and/or last quote characters if they exist (single or double quotes).
     - If the string starts with a quote character (' or ") remove it.
     - If the string ends with a quote character (' or ") remove it.
     - This handles backend responses wrapped in quotes.
  4. Detect if the unescaped content "looks like HTML" (contains '<' and '>'):
     - If yes, return new MarkupString(unescaped) so HTML renders.
     - If no, HtmlEncode unescaped content and replace newlines with "<br/>" so text looks like Word paragraphs.
  5. Return MarkupString of processed HTML.
*@

<PageTitle>Home</PageTitle>

<div class="chat-container">
    <div class="chat-header">
        <h2>Instant Non-persistent Chat</h2>
        <div>
            Try out the 
            <NavLink class="nav-link text-primary" href="myassistant">
                <span class="bi bi-plus-square-fill-nav-menu" aria-hidden="true"></span> Persistent Chat, My Personal Assistant
            </NavLink>
        </div>
    </div>

    <div class="input-row">
        <input class="message-input" placeholder="Type a message..." @bind="Message" @bind:event="oninput" @onkeydown="HandleKeyDown" />
        @if (isSending)
        {
            <div class="send-btn" disabled>...</div>
        }
        else
        {
            <button class="send-btn" @onclick="SendMessageV2">
                Send
            </button>
        }
    </div>

    <div class="chat-window" @ref="chatWindowRef">
        @if (messages.Count == 0)
        {
            <div class="empty">No messages yet. Say hello!</div>
        }
        @foreach (var m in messages.AsEnumerable().Reverse())
        {
            <div class="row">
                <div class="message-row @(m.role == "user" ? "user-row" : "bot-row float-end")">
                    <div class="avatar">@(m.role == "user" ? "You" : m.role)</div>
                    <div class="ai-response bubble @(m.role == "user" ? "bubble-user" : "bubble-bot")" style="white-space:pre-wrap; word-break:break-word">
                        @RenderMessage(m.content)
                    </div>
                </div>
            </div>
        }
    </div>

</div>


@code {
    private string Message { get; set; } = string.Empty;
    private List<DisplayChatMessage> messages = new();
    private bool isSending;
    private ElementReference chatWindowRef;
    private CancellationTokenSource _cancellationTokenSource;

    private record DisplayChatMessage(string content, string role = "user");

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(Message) || isSending)
            return;

        var userText = Message.Trim();
        messages.Add(new DisplayChatMessage(userText, "user"));
        Message = string.Empty;
        isSending = true;
        var backend = Configuration["AIBackendHost"];
        try
        {
            var dto = new { Message = userText };
            //Use relative path so it works when app is hosted with the API
            using var httpClient = new HttpClient { Timeout = TimeSpan.FromSeconds(120) };
            var response = await httpClient.PostAsJsonAsync(backend + "api/chat", new List<DisplayChatMessage> { new(userText, "user") });


            if (response.IsSuccessStatusCode)
            {
                var replyText = await response.Content.ReadAsStringAsync();                

                messages.Add(new DisplayChatMessage(replyText, "py bot"));
            }
            else
            {
                messages.Add(new DisplayChatMessage($"Error: {response.StatusCode}", "py bot"));
            }
        }
        catch (Exception ex)
        {
            messages.Add(new DisplayChatMessage($"Network error: {ex.Message}", "py bot"));
        }
        finally
        {
            isSending = false;
            await ScrollToBottomAsync();
            StateHasChanged();
        }
    }

    private async Task SendMessageV2()
    {

        if (string.IsNullOrWhiteSpace(Message) || isSending)
            return;

        ChatClient client = new(
            model: "google/gemma-3-12b",
            credential: new ApiKeyCredential("lm-studio"),
            options: new OpenAIClientOptions()
            {
                Endpoint = new Uri("http://localhost:1234/v1")
            }
        );
        var userText = Message.Trim();
        messages.Add(new DisplayChatMessage(userText, "user"));
        Message = string.Empty;
        isSending = true;
        var backend = Configuration["AIBackendHost"];
        try
        {
            var dto = new List<ChatMessage> { new UserChatMessage(userText, "user") };

            ChatCompletionOptions options = new()
            {
                Tools = { UserToolFunctions.GetUserListTool, UserToolFunctions.GetUserCountTool, UserToolFunctions.GetSingleUserTool },
            };

            @* ChatCompletion completion = await client.CompleteChatAsync(dto, options);      *@
            ChatCompletion completion;
            bool requiresAction;

            do
            {
                requiresAction = false;
                completion = await client.CompleteChatAsync(dto, options);

                switch (completion.FinishReason)
                {
                    case ChatFinishReason.Stop:
                        {
                            // Add the assistant message to the conversation history.
                            dto.Add(new AssistantChatMessage(completion));
                            break;
                        }

                    case ChatFinishReason.ToolCalls:
                        {
                            // First, add the assistant message with tool calls to the conversation history.
                            dto.Add(new AssistantChatMessage(completion));

                            // Then, add a new tool message for each tool call that is resolved.
                            foreach (ChatToolCall toolCall in completion.ToolCalls)
                            {
                                switch (toolCall.FunctionName)
                                {
                                    case nameof(UserToolFunctions.GetUserCount):
                                        {
                                            string toolResult = await UserToolFunctions.GetUserCount();
                                            dto.Add(new ToolChatMessage(toolCall.Id, toolResult));
                                            break;
                                        }

                                    case nameof(UserToolFunctions.GetUsers):
                                        {
                                            using JsonDocument argumentsJson = JsonDocument.Parse(toolCall.FunctionArguments);
                                            bool hassearchUserName = argumentsJson.RootElement.TryGetProperty("searchUserName", out JsonElement searchUserName);
                                            bool hastop = argumentsJson.RootElement.TryGetProperty("top", out JsonElement top);

                                            @* if (!hasLocation)
                                            {
                                                throw new ArgumentNullException(nameof(location), "The location argument is required.");
                                            } *@

                                            string toolResult = await UserToolFunctions.GetUsers(hassearchUserName ? searchUserName.GetString() : "", hastop ? top.GetInt32() : null);
                                            dto.Add(new ToolChatMessage(toolCall.Id, toolResult));
                                            break;
                                        }
                                    case nameof(UserToolFunctions.GetSingleUser):
                                        {
                                            using JsonDocument argumentsJson = JsonDocument.Parse(toolCall.FunctionArguments);
                                            bool hassearchUserName = argumentsJson.RootElement.TryGetProperty("searchUserName", out JsonElement searchUserName);

                                            @* if (!hasLocation)
                                            {
                                                throw new ArgumentNullException(nameof(location), "The location argument is required.");
                                            } *@

                                            string toolResult = await UserToolFunctions.GetSingleUser(searchUserName.GetString());
                                            dto.Add(new ToolChatMessage(toolCall.Id, toolResult));
                                            break;
                                        }

                                    default:
                                        {
                                            // Handle other unexpected calls.
                                            throw new NotImplementedException();
                                        }
                                }
                            }

                            requiresAction = true;
                            break;
                        }

                    case ChatFinishReason.Length:
                        throw new NotImplementedException("Incomplete model output due to MaxTokens parameter or token limit exceeded.");

                    case ChatFinishReason.ContentFilter:
                        throw new NotImplementedException("Omitted content due to a content filter flag.");

                    case ChatFinishReason.FunctionCall:
                        throw new NotImplementedException("Deprecated in favor of tool calls.");

                    default:
                        throw new NotImplementedException(completion.FinishReason.ToString());
                }
            } while (requiresAction);
            
            messages.Add(new DisplayChatMessage(completion?.Content?.FirstOrDefault()?.Text, "C# bot"));
        }
        catch (Exception ex)
        {
            messages.Add(new DisplayChatMessage($"Network error: {ex.Message}", "C# bot"));
        }
        finally
        {
            isSending = false;
            await ScrollToBottomAsync();
            StateHasChanged();
        }
    }

    // Optional method to cancel the streaming request
    private void CancelStreaming()
    {
        _cancellationTokenSource?.Cancel();
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SendMessageV2();
        }
    }

    private async Task ScrollToBottomAsync()
    {
        try
        {
            // Simple scrolling via JS Interop would be ideal, but to avoid extra files we attempt a small focus trick:
            // Focus the input then blur to nudge layout and let browser show latest content. If you prefer precise scrolling,
            // add JS to set scrollTop = scrollHeight for chatWindowRef.
            await Task.Delay(20);
        }
        catch { }
    }
    private MarkupString RenderMessage(string AiResponseText)
    {
        if (string.IsNullOrWhiteSpace(AiResponseText))
        {
            return (MarkupString)string.Empty;
        }

        // Configure Markdig with desired extensions (like code blocks, tables)
        var pipeline = new MarkdownPipelineBuilder()
            .UseAdvancedExtensions()
            .Build();

        // Convert the Markdown string to HTML
        string html = Markdown.ToHtml(AiResponseText, pipeline);

        // Cast to MarkupString to tell Blazor to render the raw HTML
        return (MarkupString)html;
    }
}